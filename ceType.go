// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

package main

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableSourceLookupTablesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["columns"]; !ok || v == nil {
		return fmt.Errorf("field columns: required")
	}
	if v, ok := raw["rows"]; !ok || v == nil {
		return fmt.Errorf("field rows: required")
	}
	type Plain TableSourceLookupTablesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TableSourceLookupTablesElem(plain)
	return nil
}

type CostElement struct {
	// Configuration corresponds to the JSON schema field "configuration".
	Configuration CostElementConfiguration `json:"configuration"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// Where the cost element value comes from. FIXED means CE will always yield the
	// same rate/amount. TABLE means the rate/amount of this CE comes from a look up
	// table. IMPORT means that this amount of this CE comes from a positions dataset
	// column.
	Source CostElementSource `json:"source"`

	// the template that this cost element is based off of
	Template CostElementTemplate `json:"template"`

	// If the CE is a RATE a value of 0.03 would mean 3% or if it is an AMOUNT 123.45
	// would mean $123.45
	ValueType CostElementValueType `json:"valueType"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AmountValueTypeFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AmountValueTypeFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AmountValueTypeFrequency, v)
	}
	*j = AmountValueTypeFrequency(v)
	return nil
}

const AmountValueTypeFrequencyYEARLY AmountValueTypeFrequency = "YEARLY"
const AmountValueTypeFrequencyMONTHLY AmountValueTypeFrequency = "MONTHLY"
const AmountValueTypeFrequencyBIANNUALLY AmountValueTypeFrequency = "BIANNUALLY"
const AmountValueTypeFrequencyHOURLY AmountValueTypeFrequency = "HOURLY"
const AmountValueTypeFrequencyQUARTERLY AmountValueTypeFrequency = "QUARTERLY"

type AmountValueType struct {
	// The frequency that this cost element is supplied. If a cost element is valid
	// during one of these periods, then it is NOT prorated. The full value for the CE
	// is applied even if it is only valid for a fraction of the period
	Frequency AmountValueTypeFrequency `json:"frequency"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AmountValueType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["frequency"]; !ok || v == nil {
		return fmt.Errorf("field frequency: required")
	}
	type Plain AmountValueType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AmountValueType(plain)
	return nil
}

type CoaSegment struct {
	// SegmentCode corresponds to the JSON schema field "segmentCode".
	SegmentCode string `json:"segmentCode"`

	// SegmentName corresponds to the JSON schema field "segmentName".
	SegmentName string `json:"segmentName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoaSegment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["segmentCode"]; !ok || v == nil {
		return fmt.Errorf("field segmentCode: required")
	}
	if v, ok := raw["segmentName"]; !ok || v == nil {
		return fmt.Errorf("field segmentName: required")
	}
	type Plain CoaSegment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoaSegment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElementValueType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CostElementValueType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CostElementValueType, v)
	}
	*j = CostElementValueType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElementTemplate) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CostElementTemplate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CostElementTemplate, v)
	}
	*j = CostElementTemplate(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElementSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CostElementSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CostElementSource, v)
	}
	*j = CostElementSource(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FixedSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain FixedSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FixedSource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElementConfiguration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["category"]; !ok || v == nil {
		return fmt.Errorf("field category: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["objectCode"]; !ok || v == nil {
		return fmt.Errorf("field objectCode: required")
	}
	if v, ok := raw["sourceDetails"]; !ok || v == nil {
		return fmt.Errorf("field sourceDetails: required")
	}
	if v, ok := raw["valueTypeDetails"]; !ok || v == nil {
		return fmt.Errorf("field valueTypeDetails: required")
	}
	type Plain CostElementConfiguration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["effectiveStartDateSource"]; !ok || v == nil {
		plain.EffectiveStartDateSource = "CUSTOM"
	}
	*j = CostElementConfiguration(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImportSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["columnName"]; !ok || v == nil {
		return fmt.Errorf("field columnName: required")
	}
	type Plain ImportSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImportSource(plain)
	return nil
}

type CostElementConfiguration struct {
	// the category of this cost element
	Category CostElementConfigurationCategory `json:"category"`

	// DefaultValue corresponds to the JSON schema field "defaultValue".
	DefaultValue *float64 `json:"defaultValue,omitempty"`

	// the description of this cost element
	Description string `json:"description"`

	// EffectiveEndDate corresponds to the JSON schema field "effectiveEndDate".
	EffectiveEndDate *InclusiveDate `json:"effectiveEndDate,omitempty"`

	// EffectiveStartDate corresponds to the JSON schema field "effectiveStartDate".
	EffectiveStartDate *InclusiveDate `json:"effectiveStartDate,omitempty"`

	// EffectiveStartDateSource corresponds to the JSON schema field
	// "effectiveStartDateSource".
	EffectiveStartDateSource CostElementConfigurationEffectiveStartDateSource `json:"effectiveStartDateSource"`

	// the name of this cost element
	Name string `json:"name"`

	// the last segment of the account string that corresponds to this cost element
	ObjectCode string `json:"objectCode"`

	// SourceDetails corresponds to the JSON schema field "sourceDetails".
	SourceDetails interface{} `json:"sourceDetails"`

	// ValueTypeDetails corresponds to the JSON schema field "valueTypeDetails".
	ValueTypeDetails interface{} `json:"valueTypeDetails"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElementConfigurationEffectiveStartDateSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CostElementConfigurationEffectiveStartDateSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CostElementConfigurationEffectiveStartDateSource, v)
	}
	*j = CostElementConfigurationEffectiveStartDateSource(v)
	return nil
}

const CostElementConfigurationCategoryOTHER CostElementConfigurationCategory = "OTHER"
const CostElementConfigurationCategoryALLOWANCE CostElementConfigurationCategory = "ALLOWANCE"
const CostElementConfigurationCategoryAFFILIATION CostElementConfigurationCategory = "AFFILIATION"

// UnmarshalJSON implements json.Unmarshaler.
func (j *RateValueTypeCalculationBasisSourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RateValueTypeCalculationBasisSourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RateValueTypeCalculationBasisSourceType, v)
	}
	*j = RateValueTypeCalculationBasisSourceType(v)
	return nil
}

type AmountValueTypeFrequency string

const CostElementConfigurationCategoryINSURANCE CostElementConfigurationCategory = "INSURANCE"
const CostElementConfigurationCategoryBASEWAGE CostElementConfigurationCategory = "BASE_WAGE"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElementConfigurationCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CostElementConfigurationCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CostElementConfigurationCategory, v)
	}
	*j = CostElementConfigurationCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RateValueTypeCalculationBasis) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["sourceIdentifier"]; !ok || v == nil {
		return fmt.Errorf("field sourceIdentifier: required")
	}
	if v, ok := raw["sourceType"]; !ok || v == nil {
		return fmt.Errorf("field sourceType: required")
	}
	type Plain RateValueTypeCalculationBasis
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RateValueTypeCalculationBasis(plain)
	return nil
}

type CostElementConfigurationCategory string

// UnmarshalJSON implements json.Unmarshaler.
func (j *RateValueType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["calculationBasis"]; !ok || v == nil {
		return fmt.Errorf("field calculationBasis: required")
	}
	type Plain RateValueType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RateValueType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["lookupTables"]; !ok || v == nil {
		return fmt.Errorf("field lookupTables: required")
	}
	type Plain TableSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TableSource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableSourceLookupTablesElemRowsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["keys"]; !ok || v == nil {
		return fmt.Errorf("field keys: required")
	}
	if v, ok := raw["label"]; !ok || v == nil {
		return fmt.Errorf("field label: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain TableSourceLookupTablesElemRowsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TableSourceLookupTablesElemRowsElem(plain)
	return nil
}

const CostElementConfigurationCategoryRETIREMENT CostElementConfigurationCategory = "RETIREMENT"
const CostElementConfigurationCategorySTIPEND CostElementConfigurationCategory = "STIPEND"
const CostElementConfigurationCategoryTAX CostElementConfigurationCategory = "TAX"
const CostElementConfigurationCategoryTOTALWAGES CostElementConfigurationCategory = "TOTAL_WAGES"
const CostElementConfigurationCategoryVARIABLEWAGE CostElementConfigurationCategory = "VARIABLE_WAGE"
const CostElementConfigurationCategoryWAGEADJUSTMENT CostElementConfigurationCategory = "WAGE_ADJUSTMENT"

type CostElementConfigurationEffectiveStartDateSource string

const CostElementConfigurationEffectiveStartDateSourceCUSTOM CostElementConfigurationEffectiveStartDateSource = "CUSTOM"
const CostElementConfigurationEffectiveStartDateSourceFISCALYEARSTART CostElementConfigurationEffectiveStartDateSource = "FISCAL_YEAR_START"
const CostElementConfigurationEffectiveStartDateSourceHIREDATE CostElementConfigurationEffectiveStartDateSource = "HIRE_DATE"
const CostElementConfigurationEffectiveStartDateSourcePOSITIONSTART CostElementConfigurationEffectiveStartDateSource = "POSITION_START"

type CostElementSource string

const CostElementSourceFIXED CostElementSource = "FIXED"
const CostElementSourceIMPORT CostElementSource = "IMPORT"
const CostElementSourceTABLE CostElementSource = "TABLE"
const CostElementSourceWAGE CostElementSource = "WAGE"

type CostElementTemplate string

const CostElementTemplateBARGAININGUNITS CostElementTemplate = "BARGAINING_UNITS"
const CostElementTemplateBONUS CostElementTemplate = "BONUS"
const CostElementTemplateCOLA CostElementTemplate = "COLA"
const CostElementTemplateEQUIPMENT CostElementTemplate = "EQUIPMENT"
const CostElementTemplateFICA CostElementTemplate = "FICA"
const CostElementTemplateHEALTH CostElementTemplate = "HEALTH"
const CostElementTemplateHOLIDAYBONUS CostElementTemplate = "HOLIDAY_BONUS"
const CostElementTemplateHOURLYWAGE CostElementTemplate = "HOURLY_WAGE"
const CostElementTemplateMCARE CostElementTemplate = "MCARE"
const CostElementTemplateMERITINCREASE CostElementTemplate = "MERIT_INCREASE"
const CostElementTemplateNONE CostElementTemplate = "NONE"
const CostElementTemplateOVERTIME CostElementTemplate = "OVERTIME"
const CostElementTemplatePENSION CostElementTemplate = "PENSION"

type CostElementValueType string

const CostElementValueTypeAMOUNT CostElementValueType = "AMOUNT"
const CostElementValueTypeRATE CostElementValueType = "RATE"

// ISO 8601 compliant in UTC.
type CreatedAt string

type EmptyObject map[string]interface{}

type FixedSource struct {
	// the fixed value of this cost element
	Value interface{} `json:"value"`
}

type ImportSource struct {
	// the column of the import positions dataset to pull cost element value from
	ColumnName string `json:"columnName"`
}

// (INDEXED)  is INCLUSIVE. ISO 8601 compliant always midnight UTC, never localized
// in UI.
type InclusiveDate string

type NonEmptyString string

type Percentage float64

type RateValueType struct {
	// The thing that the cost of this cost element is based off of. ie if your health
	// insurance is 10% of your income, then your income would be your calculation
	// basis
	CalculationBasis RateValueTypeCalculationBasis `json:"calculationBasis"`

	// maximum amount of rate value * calculationBasis value
	MaxAmount *float64 `json:"maxAmount,omitempty"`

	// minimum amount of rate value * calculationBasis value
	MinAmount *float64 `json:"minAmount,omitempty"`
}

// The thing that the cost of this cost element is based off of. ie if your health
// insurance is 10% of your income, then your income would be your calculation
// basis
type RateValueTypeCalculationBasis struct {
	// for CATEGORY, this is the category name, for POSITIONS_DATASET_COLUMN, this is
	// the column name, and for COST_ELEMENT, this is the CE id
	SourceIdentifier string `json:"sourceIdentifier"`

	// Where the calculation
	SourceType RateValueTypeCalculationBasisSourceType `json:"sourceType"`
}

type RateValueTypeCalculationBasisSourceType string

const RateValueTypeCalculationBasisSourceTypeCATEGORY RateValueTypeCalculationBasisSourceType = "CATEGORY"
const RateValueTypeCalculationBasisSourceTypeCOSTELEMENT RateValueTypeCalculationBasisSourceType = "COST_ELEMENT"
const RateValueTypeCalculationBasisSourceTypeIMPORT RateValueTypeCalculationBasisSourceType = "IMPORT"

type TableSource struct {
	// LookupTables corresponds to the JSON schema field "lookupTables".
	LookupTables []TableSourceLookupTablesElem `json:"lookupTables"`
}

type TableSourceLookupTablesElem struct {
	// (INDEXED)
	Id *string `json:"_id,omitempty"`

	// Columns corresponds to the JSON schema field "columns".
	Columns []string `json:"columns"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty"`

	// Rows corresponds to the JSON schema field "rows".
	Rows []TableSourceLookupTablesElemRowsElem `json:"rows"`
}

type TableSourceLookupTablesElemRowsElem struct {
	// Keys corresponds to the JSON schema field "keys".
	Keys []string `json:"keys"`

	// Label corresponds to the JSON schema field "label".
	Label string `json:"label"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value"`
}

// (INDEXED)
type Uuid string

var enumValues_AmountValueTypeFrequency = []interface{}{
	"YEARLY",
	"MONTHLY",
	"BIANNUALLY",
	"HOURLY",
	"QUARTERLY",
}
var enumValues_CostElementConfigurationCategory = []interface{}{
	"BASE_WAGE",
	"VARIABLE_WAGE",
	"TAX",
	"INSURANCE",
	"RETIREMENT",
	"AFFILIATION",
	"ALLOWANCE",
	"WAGE_ADJUSTMENT",
	"TOTAL_WAGES",
	"STIPEND",
	"OTHER",
}
var enumValues_CostElementConfigurationEffectiveStartDateSource = []interface{}{
	"CUSTOM",
	"FISCAL_YEAR_START",
	"POSITION_START",
	"HIRE_DATE",
}
var enumValues_CostElementSource = []interface{}{
	"FIXED",
	"TABLE",
	"IMPORT",
	"WAGE",
}
var enumValues_CostElementTemplate = []interface{}{
	"HOURLY_WAGE",
	"OVERTIME",
	"COLA",
	"MERIT_INCREASE",
	"BONUS",
	"HEALTH",
	"HOLIDAY_BONUS",
	"FICA",
	"MCARE",
	"PENSION",
	"BARGAINING_UNITS",
	"EQUIPMENT",
	"NONE",
}
var enumValues_CostElementValueType = []interface{}{
	"RATE",
	"AMOUNT",
}
var enumValues_RateValueTypeCalculationBasisSourceType = []interface{}{
	"CATEGORY",
	"IMPORT",
	"COST_ELEMENT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CostElement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["configuration"]; !ok || v == nil {
		return fmt.Errorf("field configuration: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["template"]; !ok || v == nil {
		return fmt.Errorf("field template: required")
	}
	if v, ok := raw["valueType"]; !ok || v == nil {
		return fmt.Errorf("field valueType: required")
	}
	type Plain CostElement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CostElement(plain)
	return nil
}
